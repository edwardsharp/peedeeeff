<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="P E E - D E E - E F F" />
        <meta name="theme-color" content="#ff00ff" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black" />
        <meta name="apple-mobile-web-app-title" content="PEE DEE EFF" />
        <link rel="apple-touch-icon" sizes="180x180" href="icon-192.png" />
        <link rel="apple-touch-icon" sizes="152x152" href="icon-192.png" />
        <link rel="apple-touch-icon" sizes="120x120" href="icon-192.png" />
        <link rel="apple-touch-icon" sizes="76x76" href="icon-192.png" />
        <link rel="apple-touch-icon" href="icon-192.png" />
        <link rel="manifest" href="manifest.json" />
        <link rel="icon" type="image/x-icon" href="favicon.ico" />
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="favicon-16x16.png"
        />
        <title>pee-dee-eff tee-stt-trr</title>
        <script src="pee-dee-eff.js"></script>
        <script src="cache-manager.js"></script>
        <script id="paths-data" type="application/json">
            [
                ["example/undoinganddoing", 6],
                ["geozone/disinformation", 11],
                ["geozone/safer-without-police", 13],
                ["geozone/otay-mountain", 39],
                ["geozone/the-anthropussy", 15],
                ["geozone/whirlwind-i", 17],
                ["geozone/ruptures-i", 20],
                ["geozone/the-anthropussy-print", 7],
                ["geozone/garbage-gardening", 12],
                ["geozone/strangers-print", 7],
                ["geozone/strange-natures-print", 25],
                ["geozone/jesters-freaks", 4],
                ["geozone/zine-education", 31],
                ["geozone/nyc-gentrification", 15],
                ["geozone/ruptures-i-print", 19],
                ["geozone/sounds-birmingham", 35],
                ["geozone/people-ports-power-02", 55],
                ["geozone/strange-natures", 51],
                ["geozone/foraging-art-print", 4],
                ["geozone/crisis-accomodation-print", 9],
                ["geozone/mapping-customary-practices", 67],
                ["geozone/nyc-gentrification-print", 7],
                ["geozone/start-with-a-park-print", 0],
                ["geozone/hiss2025-print-compressed", 15],
                ["geozone/handford", 6],
                ["geozone/body-territories-datafied-city", 19],
                ["geozone/whirlwind-ii", 23],
                ["geozone/esri", 16],
                ["geozone/data-centres", 22],
                ["geozone/the-words-print", 1],
                ["geozone/black-ecologies", 63],
                ["geozone/crisis-accomodation", 10],
                ["geozone/mapping-sense", 7],
                ["geozone/love-and-rage-print", 0],
                ["geozone/villes-de-guerre-quotidienne", 37],
                ["geozone/dumpster-stories-print", 7],
                ["geozone/embodying-pipeline-print", 9],
                ["geozone/energyscapes", 13],
                ["geozone/the-paradise", 95],
                ["geozone/tarde-01", 4],
                ["geozone/mapping-emotions", 79],
                ["geozone/tarde-06", 6],
                ["geozone/memorias-espanol", 35],
                ["geozone/alaskaland", 7],
                ["geozone/theoretical-self-defense", 19],
                ["geozone/heat-diary", 93],
                ["geozone/hiss2025", 16],
                ["geozone/garbage-gardening-print", 11],
                ["geozone/david-goliath", 8],
                ["geozone/the-words", 7],
                ["geozone/strangers", 15],
                ["geozone/zine-education-print", 48],
                ["geozone/mais-dauntaun-1", 95],
                ["geozone/data-centres-print", 23],
                ["geozone/anti-ableist-university", 23],
                ["geozone/embodying-pipeline", 19],
                ["geozone/elc-healthcare", 14],
                ["geozone/abolition-methodologies", 31],
                ["geozone/taming-rivers", 8],
                ["geozone/academic-rebellion-print", 9],
                ["geozone/aukaat", 72],
                ["geozone/treaty-rock", 9],
                ["geozone/defensive-design", 17],
                ["geozone/space-waste", 13],
                ["geozone/transformative-housing-print", 5],
                ["geozone/straights", 12],
                ["geozone/staircase-oskemen", 11],
                ["geozone/anti-ableist-university-alt-text", 8],
                ["geozone/remember-that-girl", 8],
                ["geozone/misoprostol-print", 11],
                ["geozone/people-ports-power-01", 41],
                ["geozone/sounds-wollongong", 67],
                ["geozone/peace-stories", 35],
                ["geozone/abolition-methodologies-print", 15],
                ["geozone/inland-empire-waterways", 7],
                ["geozone/energyscapes-print", 13],
                ["geozone/militarism-climate-crisis", 27],
                ["geozone/recuerda-esa-chica", 8],
                ["geozone/dumpster-stories", 15],
                ["geozone/love-and-rage", 7],
                ["geozone/quercus", 11],
                ["geozone/start-with-a-park", 4],
                ["geozone/misoprostol", 6],
                ["geozone/defensive-design-print", 17],
                ["geozone/academic-rebellion", 18],
                ["geozone/cities-of-banal-warfare", 37],
                ["geozone/myron-eells", 11],
                ["geozone/memorias-english", 35],
                ["geozone/militarism-climate-crisis-print", 27],
                ["geozone/foraging-art", 7],
                ["geozone/jesters-freaks-print", 7],
                ["geozone/got-power", 19],
                ["geozone/love-ctrl", 10],
                ["geozone/living-anarchy", 5],
                ["geozone/mais-dauntaun-3", 103],
                ["geozone/mais-dauntaun-4", 119],
                ["geozone/tarde-05", 2],
                ["geozone/tarde-02", 4],
                ["geozone/gaza-academics", 2],
                ["geozone/come-habla", 34],
                ["geozone/rootling", 6],
                ["geozone/transformative-housing", 11],
                ["geozone/mapping-routes", 43],
                ["geozone/mais-dauntaun-2", 91],
                ["geozone/demand-the-impossible", 25],
                ["geozone/sounds-detroit", 45],
                ["geozone/seabed-mining", 13],
                ["geozone/tarde-03", 4],
                ["geozone/rootling-print", 5],
                ["geozone/tarde-04", 6]
            ]
        </script>
        <style>
            * {
                box-sizing: border-box;
            }
            html,
            body {
                font-size: 16px;
            }
            body {
                margin: 0;
                background: black;
                color: white;
                font-family: sans-serif;
                height: 100dvh;
            }
            main {
                width: 100%;
                height: 100%;
                overflow: auto;
            }
            nav {
                position: absolute;
                top: 3rem;
                right: 0;
                width: 200px;
                max-height: calc(100dvh - 3rem);
                background: black;
                color: white;
                overflow-y: auto;
                overflow-x: hidden;
                display: none;
                flex-direction: column;
                border: thick solid magenta;
            }
            #nav-toggle {
                position: absolute;
                top: 0;
                right: 0;
                background: magenta;
                color: black;
                width: 200px;
                padding: 1rem;
                cursor: pointer;
                font-weight: bold;
                text-align: center;
                transition: opacity 0.4s ease;
            }
            #nav-toggle:hover,
            button:hover,
            input[type="radio"]:hover + label,
            input[type="checkbox"]:hover + label,
            #madewith:hover {
                background: white;
                color: black;
            }
            .tabs {
                display: flex;
                gap: 0rem;
                position: sticky;
                top: 0;
                background: black;
                z-index: 1;
            }
            .tab {
                flex: 1;
                background: black;
                color: white;
                border: none;

                cursor: pointer;
                text-align: center;
            }
            .tab.active {
                background: magenta;
                color: black;
            }
            .panel {
                display: none;
            }
            .panel.active {
                display: block;
            }
            button:hover {
                cursor: pointer;
            }
            label {
                display: block;
                margin: 1rem 0rem;
                font-weight: bold;
            }
            small {
                display: block;
                color: magenta;
                font-size: 0.75rem;
                margin-bottom: 0.25rem;
            }
            input,
            select,
            button {
                width: 100%;
                padding: 0.25rem;
                background: black;
                color: white;
                border: 1px solid white;
            }
            input[type="radio"] {
                appearance: none;
                background: black;
                color: black;
                margin: 0rem;
                height: 10px;
                max-width: 70px;
                border-radius: 0px;
            }
            input[type="radio"].vertical {
                width: 10px;
                height: 50px;
                margin-top: 5px;
                margin-bottom: -2px;
            }
            input[type="radio"]:checked {
                appearance: none;
                background: magenta;
                color: black;
            }
            .radio-group {
                display: flex;
                gap: 0.5rem;
                margin-top: 0.25rem;
            }
            .radio-group label {
                font-weight: normal;
                margin: 0;
            }
            #prop-form pre {
                margin: 0rem;
            }
            output {
                display: block;
                text-align: right;
                color: magenta;
            }
            #path-list {
                list-style: none;
                padding: 0;
                margin: 0;
            }

            #page-range-container {
                display: flex;
                gap: 1rem;
                align-items: center;
            }
            #prop-form {
                padding: 0rem 0.5rem 1rem 0.5rem;
            }
            #madewith {
                position: sticky;
                bottom: 0;
                color: black;
                background: magenta;
                text-align: right;
                padding: 0.25rem 0.25rem;
                font-size: smaller;
            }

            #cache-controls {
                padding: 1rem;
            }

            #cache-status {
                padding: 0.5rem;
                border: 1px solid magenta;
            }

            #cache-info {
                display: block;
                color: magenta;
                font-weight: bold;
            }
            #cache-progress {
                font-size: 0.9rem;
                color: #666;
                font-style: italic;
                margin-top: 0.5rem;
            }
            #cache-current {
                font-size: 0.8rem;
                color: magenta;
                font-family: monospace;
                margin-top: 0.25rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                direction: rtl;
                text-align: left;
                max-width: 100%;
            }
            #cache-current:empty {
                display: none;
            }
            #destroy-cache-button {
                margin-top: 1rem;
            }
            .zine-button {
                position: relative;
            }
            .zine-button.cached {
                filter: invert();
            }

            @media (max-width: 999px) {
                #path-list button {
                    font-size: 1.5rem;
                }

                nav,
                #nav-toggle {
                    width: 75vw;
                }
            }
        </style>
    </head>
    <body>
        <div id="nav-toggle">P E E - D E E - E F F</div>
        <nav id="flyout">
            <div class="tabs">
                <button class="tab active" data-tab="paths">ZINEZ</button>
                <button class="tab" data-tab="props">LAYOUT</button>
                <button class="tab" data-tab="cache">OFFLINE</button>
            </div>
            <div class="panel active" id="panel-paths">
                <ul id="path-list"></ul>
            </div>
            <div class="panel" id="panel-props">
                <form id="prop-form">
                    <label>
                        <pre>direction</pre>
                        <div class="radio-group">
                            <label
                                ><input
                                    type="radio"
                                    name="direction"
                                    value="horizontal"
                                    checked
                                />
                                horizontal</label
                            >
                            <label
                                ><input
                                    type="radio"
                                    name="direction"
                                    value="vertical"
                                    class="vertical"
                                />
                                vertical</label
                            >
                        </div>
                    </label>
                    <label>
                        <pre>pages-per-view</pre>
                        <div id="page-range-container">
                            <output id="ppv-output">2</output>
                            <input
                                type="range"
                                name="pages-per-view"
                                min="1"
                                max="16"
                                value="2"
                                step="1"
                            />
                        </div>
                    </label>
                    <!-- deal with these :/ -->
                    <!-- <label>
                        <pre>loop</pre>
                        <input type="checkbox" name="loop" />
                        <small>loop from end to start</small>
                    </label>
                    <label>
                        <pre>1up-first-and-last</pre>
                        <input type="checkbox" name="1up-first-and-last" />
                        <small>show first/last slides 1-up</small>
                    </label> -->
                    <label>
                        <pre>background</pre>
                        <input type="text" name="background" value="white" />
                    </label>
                </form>
            </div>
            <div class="panel" id="panel-cache">
                <div id="cache-controls">
                    <button id="cache-btn" type="button">
                        <span>CACHE ALL IMAGES</span>
                    </button>
                    <button
                        id="destroy-cache-btn"
                        type="button"
                        style="display: none; margin-top: 1rem"
                    >
                        <span>DESTROY CACHE</span>
                    </button>
                    <div id="cache-status" style="margin-top: 1rem">
                        <small id="cache-info">checking cache status...</small>
                        <div id="cache-progress"></div>
                        <div id="cache-current"></div>
                    </div>
                </div>
            </div>

            <a id="madewith" href="https://github.com/edwardsharp/peedeeeff"
                >madewith 💖 in nyc</a
            >
        </nav>

        <main>
            <pee-dee-eff id="peedeeeff"></pee-dee-eff>
        </main>

        <script>
            window.peedeeeff = document.getElementById("peedeeeff");
            const toggle = document.getElementById("nav-toggle");
            const flyout = document.getElementById("flyout");
            const tabs = document.querySelectorAll(".tab");
            const panels = document.querySelectorAll(".panel");
            // Cache UI elements
            const cacheBtn = document.getElementById("cache-btn");
            const destroyCacheBtn =
                document.getElementById("destroy-cache-btn");
            const cacheStatus = document.getElementById("cache-status");
            const cacheInfo = document.getElementById("cache-info");
            const cacheProgress = document.getElementById("cache-progress");
            const cacheCurrent = document.getElementById("cache-current");
            let isCaching = false;
            let hasCachedImages = false;
            const form = document.getElementById("prop-form");
            const ppvSlider = form.querySelector(
                "input[name='pages-per-view']",
            );
            const ppvOutput = document.getElementById("ppv-output");
            const list = document.getElementById("path-list");
            let currentBasePath = null;

            function collectFormProps() {
                const data = new FormData(form);
                const props = currentBasePath
                    ? { "base-path": currentBasePath }
                    : {};
                for (const [key, value] of data.entries()) {
                    if (key === "pages-per-view") props[key] = value;
                    else if (key === "loop" || key === "1up-first-and-last")
                        props[key] = true;
                    else props[key] = value;
                }

                // save form settings to localStorage
                saveFormSettings(props);

                return props;
            }

            function saveFormSettings(props) {
                // save all form settings including base-path
                localStorage.setItem(
                    "peedeeeff-settings",
                    JSON.stringify(props),
                );
            }

            function loadFormSettings() {
                try {
                    const saved = localStorage.getItem("peedeeeff-settings");
                    return saved ? JSON.parse(saved) : null;
                } catch (error) {
                    console.warn(
                        "failed to load settings from localStorage:",
                        error,
                    );
                    return null;
                }
            }

            function getResponsiveDefaults() {
                // check if we're on mobile/small screen
                const isMobile = window.innerWidth <= 768;
                return isMobile
                    ? {
                          "pages-per-view": "1",
                          direction: "vertical",
                      }
                    : {
                          "pages-per-view": "2",
                          direction: "horizontal",
                      };
            }

            function applyFormSettings(settings) {
                // apply base-path (saved zine selection)
                if (settings["base-path"]) {
                    currentBasePath = settings["base-path"];
                    // update the viewer with the restored base-path
                    updateViewer(settings);
                }

                // apply pages-per-view
                if (settings["pages-per-view"]) {
                    ppvSlider.value = settings["pages-per-view"];
                    ppvOutput.textContent = settings["pages-per-view"];
                }

                // apply direction
                if (settings.direction) {
                    const directionRadio = form.querySelector(
                        `input[name="direction"][value="${settings.direction}"]`,
                    );
                    if (directionRadio) {
                        directionRadio.checked = true;
                    }
                }

                // apply background color
                if (settings.background) {
                    const backgroundInput = form.querySelector(
                        'input[name="background"]',
                    );
                    if (backgroundInput) {
                        backgroundInput.value = settings.background;
                    }
                }

                // apply other checkboxes if they exist
                ["loop", "1up-first-and-last"].forEach((key) => {
                    if (settings[key]) {
                        const checkbox = form.querySelector(
                            `input[name="${key}"]`,
                        );
                        if (checkbox) {
                            checkbox.checked = true;
                        }
                    }
                });
            }

            function toggleNav(forceClose = false) {
                // if no inline style is set, nav starts closed (CSS display: none)
                const currentDisplay = flyout.style.display || "none";
                const isCurrentlyOpen = currentDisplay === "flex";

                if (forceClose || isCurrentlyOpen) {
                    flyout.style.display = "none";
                } else {
                    flyout.style.display = "flex";
                }

                return flyout.style.display === "flex";
            }

            function closeNav() {
                flyout.style.display = "none";
            }

            function isNavOpen() {
                const currentDisplay = flyout.style.display || "none";
                return currentDisplay === "flex";
            }

            // ensure nav starts in closed state
            flyout.style.display = "none";

            toggle.addEventListener("click", () => {
                toggleNav();
            });

            tabs.forEach((tab) => {
                tab.addEventListener("click", () => {
                    tabs.forEach((t) => t.classList.remove("active"));
                    panels.forEach((p) => p.classList.remove("active"));
                    tab.classList.add("active");
                    document
                        .getElementById("panel-" + tab.dataset.tab)
                        .classList.add("active");

                    // refresh cache info when CACHE tab is opened
                    if (
                        tab.dataset.tab === "cache" &&
                        window.cacheManager &&
                        window.cacheManager.isRegistered
                    ) {
                        updateCacheStatus();
                    }
                });
            });

            // initialize form settings on page load
            function initializeFormSettings() {
                // try to load saved settings first
                let settings = loadFormSettings();

                // if no saved settings, use responsive defaults
                if (!settings) {
                    settings = getResponsiveDefaults();
                    console.log("using responsive defaults:", settings);
                } else {
                    console.log("loaded yr saved settings:", settings);
                }

                // apply the settings to form controls
                applyFormSettings(settings);
            }

            // initialize settings before loading zines
            initializeFormSettings();

            const zineData = document.getElementById("paths-data")?.textContent;
            if (zineData) {
                const zinez = JSON.parse(zineData);
                const getLastSegment = (str) => {
                    const parts = str.split("/");
                    return parts[parts.length - 1] || str;
                };
                zinez.forEach(([path], index) => {
                    const li = document.createElement("li");
                    const btn = document.createElement("button");
                    btn.className = "zine-button";
                    btn.dataset.path = path;
                    btn.textContent = getLastSegment(path);
                    btn.onclick = () => {
                        currentBasePath = path;
                        updateViewer(collectFormProps());
                        closeNav();
                        resetNavVisibility(); // reset auto-hide timer after closing
                    };
                    li.appendChild(btn);
                    list.appendChild(li);

                    if (index === 0 && !currentBasePath) {
                        currentBasePath = path;
                        updateViewer(collectFormProps());
                    }
                });

                // check which zines are cached and update their styling
                updateZineCacheStatus();
            }

            form.addEventListener("change", () => {
                const props = collectFormProps();
                if (props["base-path"]) {
                    updateViewer(props);
                }
            });

            ppvSlider.addEventListener("input", () => {
                ppvOutput.textContent = ppvSlider.value;
            });

            function updateViewer(attrs) {
                const oldEl = window.peedeeeff;
                const newEl = oldEl.cloneNode(true);
                for (const name of oldEl.getAttributeNames()) {
                    newEl.removeAttribute(name);
                }
                for (const key in attrs) {
                    newEl.setAttribute(key, attrs[key]);
                }
                newEl.id = "peedeeeff";
                oldEl.replaceWith(newEl);
                window.peedeeeff = newEl;
            }

            // auto-hide nav toggle after inactivity
            let navTimeout = null;

            function resetNavVisibility() {
                toggle.style.opacity = "1";
                toggle.style.pointerEvents = "auto";
                if (navTimeout) clearTimeout(navTimeout);

                // only auto-hide if nav is NOT open
                const navIsOpen = isNavOpen();
                if (!navIsOpen) {
                    navTimeout = setTimeout(() => {
                        // double-check nav is still closed before hiding
                        if (!isNavOpen()) {
                            toggle.style.opacity = "0";
                            toggle.style.pointerEvents = "none";
                        }
                    }, 500);
                }
            }

            document.addEventListener("mousemove", resetNavVisibility);
            document.addEventListener("touchstart", resetNavVisibility);
            resetNavVisibility();

            // click-away listener 2 close da nav when clicking on something else
            document.addEventListener("click", (event) => {
                if (isNavOpen()) {
                    const isClickInside =
                        flyout.contains(event.target) ||
                        toggle.contains(event.target);
                    if (!isClickInside) {
                        closeNav();
                        resetNavVisibility(); // also reset auto-hide timer after closing
                    }
                }
            });

            async function initCacheManager() {
                if (!window.cacheManager) {
                    cacheInfo.textContent =
                        "cache not supported in this browser :(";
                    cacheBtn.disabled = true;
                    return;
                }

                const success = await window.cacheManager.init();
                if (!success) {
                    cacheInfo.textContent = "failed to initialize cache";
                    cacheBtn.disabled = true;
                    return;
                }

                // request persistent storage for better offline support
                await window.cacheManager.requestPersistentStorage();

                // check initial cache status
                await updateCacheStatus();
            }

            async function updateCacheStatus() {
                // fallback to direct cache access if service worker is unavailable
                if (!window.cacheManager || !window.cacheManager.isRegistered) {
                    try {
                        const cache = await caches.open("peedeeeff-cache-v1");
                        const keys = await cache.keys();
                        const imageKeys = keys.filter((key) =>
                            key.url.includes(".webp"),
                        );

                        hasCachedImages = imageKeys.length > 0;

                        if (hasCachedImages) {
                            cacheBtn.innerHTML =
                                "<span>CACHE REMAINING IMAGES</span>";
                            cacheBtn.style.background = "";
                            cacheBtn.style.color = "";
                            cacheBtn.style.backgroundImage = "";
                            cacheBtn.style.display = "block";
                            destroyCacheBtn.style.display = "block";
                            cacheInfo.textContent = `${imageKeys.length} images cached (service worker unavailable)`;
                        } else {
                            cacheBtn.innerHTML =
                                "<span>CACHE ALL IMAGES</span>";
                            cacheBtn.style.background = "";
                            cacheBtn.style.color = "";
                            cacheBtn.style.backgroundImage = "";
                            cacheBtn.style.display = "block";
                            destroyCacheBtn.style.display = "none";
                            cacheInfo.textContent = "no images cached yet";
                        }

                        await updateZineCacheStatus();
                        return;
                    } catch (error) {
                        console.warn("fallback cache check failed:", error);
                        cacheInfo.textContent = "cache unavailable";
                        return;
                    }
                }

                try {
                    const status = await window.cacheManager.getCacheStatus();
                    hasCachedImages =
                        status.cacheExists && status.totalCached > 0;

                    if (hasCachedImages) {
                        cacheBtn.innerHTML =
                            "<span>CACHE REMAINING IMAGES</span>";
                        cacheBtn.style.background = "";
                        cacheBtn.style.color = "";
                        cacheBtn.style.backgroundImage = "";
                        cacheBtn.style.display = "block";
                        destroyCacheBtn.style.display = "block";
                        cacheInfo.textContent = `${status.totalCached} images cached`;
                    } else {
                        cacheBtn.innerHTML = "<span>CACHE ALL IMAGES</span>";
                        cacheBtn.style.background = "";
                        cacheBtn.style.color = "";
                        cacheBtn.style.backgroundImage = "";
                        cacheBtn.style.display = "block";
                        destroyCacheBtn.style.display = "none";
                        cacheInfo.textContent = "no images cached yet";
                    }

                    // show storage estimate if available
                    const estimate =
                        await window.cacheManager.getStorageEstimate();
                    if (estimate && estimate.usage > 0) {
                        const mbUsed = (estimate.usage / (1024 * 1024)).toFixed(
                            1,
                        );
                        cacheInfo.textContent += ` • ${mbUsed}MB used (${estimate.percentUsed}% of storage)`;
                    }

                    // clear progress indicators
                    cacheProgress.textContent = "";
                    cacheCurrent.textContent = "";

                    // update zine cache status indicators
                    await updateZineCacheStatus();
                } catch (error) {
                    console.error("Failed to get cache status:", error);
                    cacheInfo.textContent = "service worker unavailable";
                }
            }

            async function handleCacheAction() {
                if (isCaching) return;

                try {
                    // cache images (all or remaining)
                    isCaching = true;
                    cacheBtn.innerHTML = "<span>CACHING...</span>";
                    cacheBtn.disabled = true;
                    destroyCacheBtn.disabled = true;
                    cacheProgress.textContent = "discovering images...";
                    cacheCurrent.textContent = "";

                    let currentProgress = 0;
                    let totalImages = 0;

                    await window.cacheManager.cacheAllImages((progress) => {
                        console.log("cache progress callback:", progress);
                        switch (progress.type) {
                            case "discovering":
                                cacheProgress.textContent = `checking ${progress.current}/${progress.total} folders`;
                                cacheCurrent.textContent = progress.folder;
                                break;
                            case "start":
                                totalImages = progress.total;
                                currentProgress = 0;
                                cacheProgress.textContent = `caching ${progress.total} images...`;
                                cacheCurrent.textContent = "";
                                updateButtonProgress(0);
                                break;
                            case "progress":
                                currentProgress++;
                                const percentage = Math.round(
                                    (currentProgress / totalImages) * 100,
                                );
                                cacheProgress.textContent = `${currentProgress}/${totalImages} (${percentage}%)`;
                                cacheCurrent.textContent = progress.url;
                                updateButtonProgress(percentage);
                                // update cache status periodically during progress
                                if (currentProgress % 10 === 0) {
                                    setTimeout(() => {
                                        updateCacheStatus().catch(() => {
                                            // ignore errors during progress updates
                                        });
                                    }, 100);
                                }
                                break;
                            case "complete":
                                updateButtonProgress(100);
                                cacheProgress.textContent = `cached ${progress.cached} images! ${progress.failed > 0 ? `(${progress.failed} failed)` : ""}`;
                                cacheCurrent.textContent = "";
                                setTimeout(() => {
                                    cacheProgress.textContent = "";
                                    cacheCurrent.textContent = "";
                                    updateCacheStatus();
                                }, 3000);
                                break;
                            case "error":
                                cacheProgress.textContent = `error: ${progress.error}`;
                                cacheCurrent.textContent = "";
                                break;
                        }
                    });
                } catch (error) {
                    console.error("oopz, cache operation failed:", error);
                    cacheProgress.textContent = `error: ${error.message}`;
                    cacheCurrent.textContent = "";
                } finally {
                    isCaching = false;
                    cacheBtn.disabled = false;
                    destroyCacheBtn.disabled = false;
                    cacheBtn.style.setProperty("--progress", "0%");
                }
            }

            async function handleDestroyCacheAction() {
                if (isCaching) return;

                try {
                    isCaching = true;
                    destroyCacheBtn.innerHTML = "<span>DESTROYING...</span>";
                    cacheBtn.disabled = true;
                    destroyCacheBtn.disabled = true;
                    cacheProgress.textContent = "clearing cache...";
                    cacheCurrent.textContent = "";

                    await window.cacheManager.clearCache();
                    cacheProgress.textContent = "cache destroyed";

                    setTimeout(() => {
                        cacheProgress.textContent = "";
                        cacheCurrent.textContent = "";
                        updateCacheStatus();
                    }, 2000);
                } catch (error) {
                    console.error("eek! cache clear failed:", error);
                    cacheProgress.textContent = `error: ${error.message}`;
                    cacheCurrent.textContent = "";
                } finally {
                    isCaching = false;
                    cacheBtn.disabled = false;
                    destroyCacheBtn.disabled = false;
                }
            }

            function updateButtonProgress(percentage) {
                // TODO do better here
                cacheBtn.style.setProperty("--progress", percentage + "%");
                cacheBtn.style.background = `linear-gradient(to right, magenta 0%, magenta ${percentage}%, transparent ${percentage}%, transparent 100%)`;
                cacheBtn.style.backgroundSize = "100% 100%";
                cacheBtn.style.backgroundRepeat = "no-repeat";
            }

            async function updateZineCacheStatus() {
                // skip service worker check for offline compatibility
                if (!("caches" in window)) {
                    return;
                }

                try {
                    const cache = await caches.open("peedeeeff-cache-v1");
                    const cachedRequests = await cache.keys();
                    const cachedUrls = cachedRequests.map((req) => req.url);

                    // check each zine button
                    const zineButtons =
                        document.querySelectorAll(".zine-button");
                    zineButtons.forEach((btn) => {
                        const path = btn.dataset.path;
                        if (!path) return;

                        // check if any images from this zine are cached
                        // be more flexible with URL matching for offline scenarios
                        const hasImages = cachedUrls.some((url) => {
                            const urlPath = new URL(url).pathname;
                            return (
                                urlPath.includes(path) &&
                                urlPath.includes("/page-")
                            );
                        });

                        if (hasImages) {
                            btn.classList.add("cached");
                        } else {
                            btn.classList.remove("cached");
                        }
                    });
                } catch (error) {
                    console.warn("failed to check zine cache status:", error);
                    // fallback: try to preserve existing cached indicators
                }
            }

            cacheBtn.addEventListener("click", handleCacheAction);
            destroyCacheBtn.addEventListener("click", handleDestroyCacheAction);

            initCacheManager();

            document.addEventListener("visibilitychange", () => {
                if (
                    !document.hidden &&
                    window.cacheManager &&
                    window.cacheManager.isRegistered
                ) {
                    setTimeout(updateCacheStatus, 500);
                }
            });
        </script>
    </body>
</html>
